# Linux系统编程
## Day2
### 1. Vim三种工作模式
Vi有三种基本工作模式: 命令模式、文本输入模式、末行模式。
![在这里插入图片描述](https://img-blog.csdnimg.cn/c06dc943c1584f27b543875679a8d174.png)
通过shell命令进入命令模式。
1. 用户按下esc键, 就可以使vi进入命令模式下; 当使用vi打开一个新文件开始也是进入命令模式下.
2. 从命令模式切换到文本输入模式只需输入如下命令: i
3. 从命令模式切换到末行模式, 输入冒号:,存在以下命令
![末行模式的命令](https://img-blog.csdnimg.cn/5b7ec1d194c34fd390dca545d7e5c875.png)

### 2. gcc
#### gcc的工作流程
从hello.c到可执行文件实际上有四步
1. **预处理:	gcc -E test.c -o test.i //-o就是output到某文件**
- .i结尾
- 头文件展开----不检查语法错误，可以展开任意文件
- 宏定义替换。 --- 将宏名替换回宏值。

2. **编译:gcc -S test.i -o test.s**
- .s结尾
- 逐行检查语法错误【重点】，耗时最长
- 将c翻译成汇编指令
	
3. **汇编:gcc -c test.s -o test.o**
- .o结尾
- 将汇编指令翻译成二进制编码

5. **链接:gcc -o test test.o**
**or** gcc test.c -o test（直接）
- 无结尾
- 链接test.c代码中调用的库函数
#### gcc常用命令
- -v  查看gcc版本号, --version也可以
- -E  生成预处理文件
- -S  生成汇编文件
- -c  只编译, 生成.o文件, 通常称为目标文件
- -I   指定头文件所在的路径
- -L   指定库文件所在的路径
- -l    指定库的名字
- -o   指定生成的目标文件的名字
- -g   包含调试信息, 使用gdb调试需要添加-g参数

### 3.  静态库和共享库
#### 3.1 库的介绍
库是二进制文件, 是源代码文件的另一种表现形式, 是**加了密的源代码**;  是一些功能相近或者是相似的函数的集合体.
#### 3.2 库制作完成后, 如何给用户使用
需要两个文件，用户才能使用：
- 头文件(.h文件)---包含了库函数的声明
- 库文件(.a文件或者.so文件)---包含了库函数的代码实现

<font color='red'> 注意: 库不能单独使用, 只能作为其他执行程序的一部分完成某些功能, 也就是说只能被其他程序调用才能使用.
 </font>
####  3.3 静态库（static library）
静态库可以认为是一些目标代码的集合, 是在**可执行程序运行前就已经加入到执行码中**, 成为执行程序的一部分. 按照习惯, 一般以.a做为文件后缀名。静态库文件一般由**多个.o文件制作成一个.a文件**，具体看下一小节**静态库的制作**
- 前缀：lib
- 库名称：自定义即可, 如test
- 后缀：.a

所以最终的静态库的名字应该为：libtest.a
&emsp;&emsp;注意：一个.o文件也能看作是库文件，是库文件的一个特例，库文件一般由多个.o文件构成

##### 3.3.1 静态库的制作
1. 将.c文件制作成.o文件
```
gcc -c fun1.c fun2.c
//可以不加-o默认生成对应的.o文件
```

3. 使用ar命令将.o文件打包成.a文件
```
ar rcs libtest1.a fun1.o fun2.o
```
##### 3.3.2 静态库的使用
1. main.c(调用了库文件的文件)与head.h和libtest1.a**在同一级目录的情况**
```
gcc -o main1 main.c -I./ -L./ -l test1
```
- 注:-I(i的大写)   指定头文件所在的路径
&emsp;-L   指定库文件所在的路径
&emsp;-l    指定库的名字

2. main.c与head.h和libtest1.a在**不同一级目录的情况**
```
gcc -o main1 main.c -I./include -L./lib -l test1
```
#### 3.4 动态库

静态库是.a结尾，动态库则是以.so结尾，还没学，略。
## Day3
### 1.  Makefile

makefile文件中定义了一系列的规则来指定, 哪些文件需要先编译, 哪些文件需要后编译, 哪些文件需要重新编译, 甚至于进行更复杂的功能操作, 因为makefile就像一个Shell脚本一样, 其中也可以执行操作系统的命令.  makefile带来的好处就是——“自动化编译”, 一旦写好, **只需要一个make命令, 整个工程完全自动编译**, 极大的提高了软件开发的效率。 makefile文件是用来管理项目工程文件，通过执行make命令，**make就会自动解析并执行makefile文件**。

#### 1.1 makefile的基本规则
makefile由一组规则组成,规则如下:
目标（要生成的目标文件）: 依赖(生成目标所依赖的文件)
（tab）命令

makefile基本规则三要素：
- 目标: 要生成的目标文件
- 依赖: 目标文件由哪些文件生成
- 命令: 通过执行该命令由依赖文件生成目标

例如
```
main: main.c fun1.c fun2.c
	gcc -o main main.c fun1.c fun2.c
```

#### 1.2 makefile的工作原理

要想生成目标文件，先要检查依赖条件是否都存在：
- 若都存在，则比较目标时间和依赖的时间，如果依赖的时间比目标的时间新，
则重新生成目标；否则不重新生成。
- 若不存在，则往下找有没有生成依赖的规则，有则生成，没有则报错。
![在这里插入图片描述](https://img-blog.csdnimg.cn/94421db31bc24e81ad56c1abbec1a820.png)
#### 1.3 makefile中的变量（不记，只当需要的时候查找使用）
在makefile中使用变量有点类似于C语言中的宏定义, 使用该变量相当于内容替换, 使用变量可以使makefile易于维护, 修改起来变得简单。
makefile有三种类型的变量:
- 普通变量: var=hello, $(var)
- 自带变量:
&emsp;CC = gcc #arm-linux-gcc
&emsp;CPPFLAGS : C预处理的选项 -I
&emsp;CFLAGS:   C编译器的选项 -Wall -g -c
&emsp;LDFLAGS :  链接器选项 -L  -l
- 自动变量(**特别注意：自动变量只能在规则的命令中使用**.)
&emsp; $@: 表示规则中的目标
&emsp; $<: 表示规则中的第一个依赖条件
&emsp; $^: 表示规则中的所有依赖条件, 组成一个列表, 以空格隔开, 如果这个列表中有重复的项则消除重复项。

模式规则:
&emsp; %.0:%.c //前后的%代表字符串，必须相同。
比如：main.o:main.c  fun1.o: fun1.c  fun2.o:fun2.c, 说的简单点就是: xxx.o:xxx.c(%.0:%.c)

#### 1.4 makefile函数与清理
标记一下，没学。对应07-makefile的第五个版本。

### 2.  gdb
标记一下，美学。对应08-gdb介绍 到 4-gdb调试综合练习

### 3.  文件IO
C语言使用fopen函数打开一个文件, 返回一个FILE* fp, fp指向堆空间，堆空间存放的不是文件本身，而是文件的描述信息的结构体。
![36a7b770c79198361d.png)](https://img-blog.csdnimg.cn/7e81c82117be4a4f80023554364022a2.png)
这个指针指向的结构体有三个重要的成员：
- 	**文件描述符:** 通过文件描述符可以找到文件的**inode**, 通过inode可以找到对应的数据块
- **文件指针**: 读和写共享一个文件指针, 读或者写都会引起文件指针的变化
- **文件缓冲区**: 读或者写会先通过文件缓冲区, 主要目的是为了减少对磁盘的读写次数, 提高读写磁盘的效率.

### 4.  C库函数和系统函数
标记一下，没学。对应16-C库函数和系统函数的关系。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2a830427f61146cd8ab42f1a907a811e.png)

### 5. 虚拟地址空间
用户区的内存4区模型：
	
- 代码段：.text段。 程序源代码（二进制形式）。

- 数据段：只读数据段 .rodata段。初始化数据段 .data段。 未初始化数据段 .bss 段。

- stack：栈。 在其之上开辟 栈帧。	windows 1M --- 10M	Linux： 8M --- 16M

- heap：堆。 给用户自定义数据提供空间。 约 1.3G+

进程的虚拟地址空间分为**用户区**和**内核**区, 其中内核区是受保护的, 用户是不能够对其进行读写操作的;

内核区中很重要的一个就是进程管理, 进程管理中有一个区域就是PCB(**本质是一个结构体**)，称进程控制块;
PCB中有文件描述符表, **文件描述符表中存放着打开的文件描述符**, 涉及到文件的IO操作都会用到这个文件描述符.


### 6. PCB与文件描述符
每一个进程有一个PCB。PCB是一个结构体，其中有一项是文件描述符表，文件描述符表中存放着打开的文件描述符。

一个进程默认会打开三个文件：标准输入，标准输出，标准出错，对应index：0，1，2。每当进程每打开一个文件，就会在文件描述符表上记录一个文件描述符。

![在这里插入图片描述](https://img-blog.csdnimg.cn/d499f0ad0f38482e880376b1d1130dfe.png)
&emsp;&emsp;强调：文件描述符的作用：通过文件描述符可以找到文件的**inode**, 通过inode可以找到对应的数据块。

## Day4
linux下文件IO操作。没看。
## Day5（进程）
### 1. 程序与进程
- 程序，是指编译好的二进制文件，在磁盘上，占用磁盘空间, 是一个**静态**的概念.
- 进程，一个启动的程序， 进程占用的是系统资源，如：物理内存，CPU，终端等，是一个**动态**的概念

### 2. 并行和并发
- 并发：在一个时间段内, 是在同一个cpu上, 同时运行多个程序。（时间片等）
- 并行：并行性指两个或两个以上的程序在同一时刻发生(需要有多颗cpu)。

### 3. PCB-进程控制块
每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息，Linux内核的进程控制块是task_struct结构体。

PCB中有很多信息：主要有
- 进程id。系统中每个进程有唯一的id，在C语言中用pid_t类型表示，其实就是一个非负整数。
- 进程的状态，有初始、就绪、运行、阻塞（挂起）、停止五个状态。
- 进程切换时需要保存和恢复的一些CPU寄存器。
- 描述虚拟地址空间的信息。
- 描述控制终端的信息。
- 当前工作目录（Current Working Directory）。
- umask掩码。（用于获取文件的权限信息）
- 文件描述符表，包含很多指向file结构体的指针。
- 和信号相关的信息。
- 用户id和组id。
- 会话（Session）和进程组。
- 进程可以使用的资源上限（Resource Limit）。ulimit -a


### 4. 进程状态的转化
![](https://img-blog.csdnimg.cn/b0e5bddfa12f4c40b37d34991f0ddcef.png)

### 5. fork()
头文件 <unistd.h>
#### 5.1 fork()原理
fork函数的作用：产生子进程

fork函数一次调用，两次返回：父进程返回子进程的ID，子进程返回0

fork函数的执行逻辑
![在这里插入图片描述](https://img-blog.csdnimg.cn/b83bb96bec6a4a3eb790107373339e37.png)


调用fork函数的内核实现原理：除了修改内核区中PCB的进程id外，其他全部复制一份到子进程

![在这里插入图片描述](https://img-blog.csdnimg.cn/267b29efac2d4ab2a19bd586d67e5a0b.png)
fork函数总结：
1.fork函数的返回值：
- 父进程返回子进程的PID，是一个大于0数;
- 子进程返回0；
- 特别需要注意的是：**不是fork函数在一个进程中返回2个值，而是在父子进程各自返回一个值。**
2. 子进程创建成功后，代码的执行位置：父进程执行到什么位置，子进程就从哪里执行
3. 区分父子进程：通过fork函数的返回值
4. 父子进程的执行顺序：不一定，哪个进程先抢到CPU，哪个进程就先执行

#### 5.2 fork()代码
```cpp
pid_t pid=fork()
if(pid<0)
{
	printf("创建失败");
	exit(1);
}
if(pid==0)//子进程执行的片段
{
	pid=getpid();//获取当前进程的pid
	pid=getppid();//获取当前进程的父进程pid
}
if(pid>0)//父进程执行的片段
{
	yyy;
}
```
当父进程比子进程先结束时，子进程的父进程pid会变成1

#### 5.3 父子进程不能共享全局变量
如标题所示，原因是：会把父进程的用户区完全copy一份给子进程，所以子进程也有自己的全局变量。而且，如果共享的话，还要**进程间通信**干嘛？

写时复制，读时共享：
- 如果父子进程仅仅是对变量做“读”操作，这时候该变量在物理内存中是共享的（节省空间）。
- 如果说父子进程中的某进程对变量进行修改，则会复制一份该数据的副本，在副本上对该数据进行修改，并映射回虚拟地址。如图所示
![看图中间的箭头](https://img-blog.csdnimg.cn/d0ba96fc080f46588c3c8b6405d199ce.png)


所以父子进程不能通过全局变量进程通信！如果父子进程想要通信，必须借助其他工具。

### 6. ps命令和kill命令
ps：查看进程相关信息。
kill：**用于向运行中的进程发送信号**，默认发送的信号是终止信号，会请求进程退出。不一定是杀死进程，也可以发送其他信号。

主要用法
1.
ps aux | grep "xxx"//grep 关键字:可以查看启动信息中包含关键字的进程
ps ajx | grep "xxx"
- -a：（all）当前系统所有用户的进程
- -u：查看进程所有者及其他一些信息
- -x：显示没有控制终端的进程 -- 不能与用户进行交互的进程【输入、输出】
- -j: 列出与作业控制相关的信息
2.
kill -l 查看系统有哪些信号
kill -9 pid 杀死某个线程


### 7. exec
exec：想在一个进程中：**执行一个应用程序**或者想**执行一个系统命令**，应先fork，再在子进程中执行execl拉起可执行程序或者命令。
```c
pid = fork()
if(pid==0)//让子进程执行
{
	int excel (path,"ls", "-l", NULL)
	//调用execl函数后，子进程的代码段会被ls命令代码段替换。
	//注意：子进程的地址空间没有变化 ，子进程的PID	也没有变化。
}
```

execl实现原理：
&emsp;&emsp;当调用子进程使用execl时，子进程的地址空间中的代码段(.txt)、数据段，堆和栈等将被替换成execl中所执行的新进程。原有的进程空间没有发生变化，**并没有创建新的进程**，进程PID没有发生变化。
![在这里插入图片描述](https://img-blog.csdnimg.cn/aae110cbc8384be98e7df75c64e52ae8.png)

exec有六大函数，记住两个主要的函数：
#### 7.1  execl()  

一般execl用于**自己写的一个应用程序**

函数原型：
&emsp;&emsp;int execl("绝对路径", "标识符",  "参数1","参数2" ,NULL);
```cpp
excel("./test", "test", "Hello","world", NULL);
excel("/bin/ls", "ls", "-l", NULL);
```
参数介绍：
- 绝对路径	const char* ，文件存储的绝对路径，可通过pwd命令查看
- 标识符(占位符)	const char* ，取个别名
- 参数	------	执行该程序/命令所需要的参数(例如ls的-l)
- NULL	------	最后这个必须传NULL，否则函数会报错

返回值：若是成功，则不返回，不会再执行exec函数后面的代码；
若是失败，会执行execl 后面的代码，可以用perror打印错误原因。

#### 7.2 execlp()  

一般execlp用于**执行系统命令**

函数原型:
&emsp;&emsp;int execlp("命令名/程序名"，"标识符", "参数1","参数2", NULL);
```cpp
execlp("ls", "ls", "-l", NULL);
```
参数介绍：
- 命令名/程序名：执行命令的名字(例如ls)，根据**PATH 环境变量**来搜索该命令(加上路径也可以，如果执行命令就不需要加路径，如果执行程序，就把路径加上)
- 标识符(占位符)	const char* ，取个别名
- 参数	------	执行该程序/命令所需要的参数(例如ls的-l)
- NULL	------	最后这个必须传NULL，否则函数会报错

返回值：若是成功，则不返回，不会再执行exec函数后面的代码；若是失败，会执行


### 8. 子进程资源回收
当一个子进程退出之后，子进程只能**回收自己的用户区的资源**，但是不能回收内核空间的PCB资源，必须由它的父进程调用**wait**或者**waitpid函数**完成对子进程资源的回收，避免造成系统资源的浪费。

### 9. 孤儿进程
若父进程先退出，子进程就变成孤儿进程。

并且为了保证每个进程都有一个父进程，孤儿进程会被init进程领养，init进程成为了孤儿进程的养父进程，当孤儿进程退出之后，由init进程完成对孤儿进程的回收。
### 10. 僵尸进程
子进程先退出，父进程没有完成对子进程的回收（回收内核区资源），此时子进程变成僵尸进程。
如何解决僵尸进程：
&emsp;&emsp;使用杀死僵尸进程父进程的方法来解决僵尸进程。原因是：杀死其父进程可以让init进程领养僵尸进程,最后由init进程回收僵尸进程.

### 11. 子进程回收函数
头文件 <sys/wait.h>
　<font color='red'>所有的进程回收函数都必须由**父进程**完成！！ </font>
#### 11.1 wait函数

**函数原型**：pid_t wait(int *status);
**函数作用：**
- **阻塞**并等待子进程退出：会阻塞父进程！父进程会等到子进程执行完退出才接着运行父进程。
- 回收子进程残留资源 
- 获取子进程结束状态(退出原因)。

**返回值：**
- 成功：清理掉的子进程ID；
- 失败：-1 (没有子进程)

**status参数**:传出参数(有点像值-结果参数)
- WIFEXITED(status)：为非0        → 进程正常结束
- WEXITSTATUS(status)：获取进程退出状态 
- WIFSIGNALED(status)：为非0 → 进程被信号杀死的
- WTERMSIG(status)：取得进程终止的信号编号。

如果对状态不关心，就传NULL就行。

```cpp
pid_t pid=fork()

if(pid>0)//父进程执行
{
	printf("this is father pid=%d", getpid());
	pid_t w_pid=wait(NULL);//在父进程执行wait函数进行子进程的资源回收
}
if(pid==0)//子进程执行
{
	printf("this is son pid=%d", getpid());
}
```

#### 11.2 waitpid函数
**函数原型**：pid_t waitpid(pid_t pid, int *status, in options);
**函数作用：**
同wait函数。但是比wait函数灵活，**可以控制是否阻塞父进程**。
**函数参数:**
- pid：
 &emsp;&emsp;pid = -1 等待任一子进程。与wait同效果。
 &emsp;&emsp;pid > 0 等待其进程ID与pid相等的子进程。
 - status: 子进程的退出状态，用法同wait函数。
 - options：设置父进程是否阻塞，默认阻塞。设置为WNOHANG，函数非阻塞。
 
**返回值：**
- \>0：返回回收掉的子进程ID；
- -1：无子进程
- =0：参3为WNOHANG，且目前没有子进程退出。


**status参数**:传出参数(有点像值-结果参数)
- WIFEXITED(status)：为非0        → 进程正常结束
- WEXITSTATUS(status)：获取进程退出状态 
- WIFSIGNALED(status)：为非0 → 进程被信号杀死的
- WTERMSIG(status)：取得进程终止的信号编号。

如果对状态不关心，就传NULL就行。
## Day6（进程间通信）
### 1. 进程间通信的基本概念
Linux环境下，进程地址空间相互独立，每个进程各自有不同的用户地址空间。任何一个进程的全局变量在另一个进程中都看不到，所以进程和进程之间不能相互访问，<font color='red'> 要交换数据必须通过**内核** </font>。具体来说，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**（**IPC**，InterProcess Communication）。
![在这里插入图片描述](https://img-blog.csdnimg.cn/596a8238029e44cead74021b739fb82e.png)
### 2. 进程间通信的方式
在进程间完成数据传递需要借助操作系统提供特殊的方法,现今常用的进程间通信方式有：
- **管道** (有血缘关系使用，使用最简单)
- **信号** (开销最小)
- **共享映射区** (无血缘关系)
- **本地套接字** (最稳定)

### 3. 利用管道的方式进行进程间通信
**管道应用于有血缘关系的进程之间。**
#### 3.1 管道的概念
管道是一种最基本的IPC机制，也称匿名管道，应用于**有血缘关系的进程之间**，进行数据传递。调用pipe函数即可创建一个管道。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2fc610dd709649758664f9ae932d1f9a.png)



管道的特点
- 管道的本质是一块内核缓冲区 ，**数据只要读就没了。**（防止管道满）
- 由两个**文件描述符引用**，一个表示读端，一个表示写端。
- 规定数据从管道的写端流入管道，从读端流出。
- 当两个进程都终止的时候，管道也自动消失。
- 管道的读端和写端默认都是**阻塞**的。

注意：父进程创建管道，子进程会继承。

**原理：**
- 管道内部使用**环形队列**实现。
- 默认缓冲区大小为4K，可以使用ulimit -a命令获取大小。
- 实际操作过程中缓冲区会根据数据压力做适当调整。

**局限性**：
- 数据一旦被读走，便不在管道中存在，**不可反复读取**。
- **数据只能在一个方向上流动**，若要实现双向流动，必须使用两个管道
- 只能在**有血缘关系的进程间**使用管道。

为什么管道只能在有血缘关系的进程间使用：
&emsp;&emsp;管道的两端是通过文件描述符表示的，如果是两个毫不相关的进程，在一个进程内创建了管道，没办法让另一个进程获得该管道的文件描述符。但是在父子进程中就可以。

## Day7（信号）
### 1. 信号的基本介绍
进程A给进程B发送信号，进程B收到信号之前执行自己的代码，收到信号后，**不管执行到程序的什么位置，都要暂停运行，去处理信号**，处理完毕后再继续执行。与硬件中断类似——异步模式。但信号是软件层面上实现的中断，早期常被称为“软中断”。
<font color='red'> 每个进程收到的所有信号，都是由内核负责发送的 </font>

几个常用到的信号：
SIGINT、SIGQUIT、SIGKILL、SIGSEGV、SIGUSR1、SIGUSR2、SIGPIPE、SIGALRM、SIGTERM、SIGCHLD、SIGSTOP、SIGCONT
SIGCHLD：子进程退出后，内核会给父进程发送该信号。

#### 1.1 信号的状态
信号有三种状态：产生、未决和递达。
1. 信号的产生：
- 按键产生，如：Ctrl+c、Ctrl+z、Ctrl+\
- 系统调用产生，如：kill、raise、abort
- 软件条件产生，如：定时器alarm
- 硬件异常产生，如：非法访问内存(段错误)、除0(浮点数例外)、内存对齐出错(总线错误)
-  命令产生，如：kill命令
2. 未决：产生和递达之间的状态。主要由于阻塞(屏蔽)导致该状态。 
3. 递达：递送并且到达进程。
#### 1.2 信号的处理方式
信号的处理方式有三种：
- 执行默认动作 （绝大多数都是终止，因为终止对系统产生影响最小）：
Term：终止进程
Ign：忽略信号 (默认即时对该种信号忽略操作)
Core：终止进程，生成Core文件。(查验死亡原因，用于gdb调试)
Stop：停止（暂停）进程
Cont：继续运行进程
- 忽略信号(丢弃不处理)
- **捕捉信号**(调用用户的自定义的处理函数)：需要告诉内核，用户希望如何处理某一种信号，说白了就是**用户写一个信号处理函数**，然后将这个函数告诉内核。当该信号产生时，由**内核来调用用户自定义的函数**，以此来实现某种信号的处理。

注意：SIGKILL和SIGSTOP不能捕获，不能阻塞，不能忽略。只能执行他们的默认动作。SIGKILL的默认动作是终止，SIGSTOP的默认动作是暂停。

### 2. 信号相关函数
#### 2.1 signal函数
作用：注册信号捕捉函数
函数原型
```cpp
void handler(int signum);//信号处理函数
sighandler_t signal(int signum, sighandler_t handler);//注册信号处理函数
//signum：信号编号
//handler：信号处理函数
```
注意：内核执行的信号处理函数，不是进程执行。

#### 2.1 kill函数
